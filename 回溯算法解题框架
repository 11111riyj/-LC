##回溯算法解题框架
  #回溯算法
  回溯算法要点在于是一种暴力搜索，回溯算法是在遍历「树枝」，DFS 算法是在遍历「节点」
  回溯算法的思路：
  1、路径：就是已经做出的选择。（在某层做完选择时，记得回溯，也就是撤销操作，采用的有list.pop()）

  2、选择列表：就是你当前可以做的选择。

  3、结束条件：就是到达决策树底层，无法再做选择的条件。
  
  **回溯算法代码框架**
  result = []
  def backtrack(路径, 选择列表):
      if 满足结束条件:
          result.add(路径)
          return

      for 选择 in 选择列表:
          做选择
          backtrack(路径, 选择列表)
          撤销选择
          
  **核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」**
  
  #例题<LC 46 全排列>
  
  题目要求：给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。
  
  例子：输入：nums = [1,2,3]
  输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
  
  
  思路：采用例如决策树的思想，第一次选择1，第二次在剩下的数字里选择，以此类推
  
  核心代码：
  
  for i in range(nums):
    if used[i]: #如果该位置的数字已经被使用过，则不再使用
      continue
    temp.append(nums[i])  #未使用添加入temp中
    used = True #更新状态 在下一次递归时，更新used状态
    backtrack(nums,res,temp,used) #注意 nums,res,temp,used 均为全局变量
    used = False #撤回操作 已经跑完并return了 并且属于轮次的i已经过了 无需担心重复添加问题
    temp.pop() #撤回操作
    
  
  代码：
  class Solution:
      def permute(self, nums: List[int]) -> List[List[int]]:
          #设置全局变量
          res = []
          temp = []
          used = [False for i in range(len(nums))]
        #核心函数 backtrack
          def backtrack(nums,res,temp,used):
              #思路3：结束条件
              if len(temp) == len(nums):
                  res.append(temp[:])
                  return #退出递归 返回空值
              #思路1：做出选择
              for i in range(len(nums)):
                  if used[i]: #used为思路2：选择列表
                      continue
                  temp.append(nums[i])
                  used[i] = True
                  backtrack(nums,res,temp,used)
                  used[i] = False
                  temp.pop()
          #调用函数
          backtrack(nums,res,temp,used)
          return res
          
    
   
    
  
 
 
 
 
 
 
