# LC 1143

**题目要求**
给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可
以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

**思路**
创建一个二维dp 维度为len(text1)+1 * len(text2)+1  dp[i][j]的意思是text1[0：i-1] text[0：j-1]最长公共子序列长度
**为什么要+1** 因为在dp内添加一行一列表示 当text1[0] 和text2[0]的情况 也就是dp[i][j] i j 中有一个为0的情况 

***动态规划的重中之重——状态转移方程*** 
由于dp中行列都被添加一行 所有当dp[i][j] 时记录的其实是text1[0：i-1] text[0：j-1]的最长公共子序列长度
此时有个思路转移 设置最长公共子序列为LCS = 'xxx'  若text1[i-1] == text[j-1]时（也就是子数组的最后一个数相等时） text1[i-1] 一定在LCS中 此时dp[i][j] = dp[i-1][j-1] + 1 更新最长子序列的长度
反之 则text1[i-1]、text[j-1]至少有一个不再LCS中 当前位置的长度为之前长度的最大值 
**举个栗子**
有text1 = ‘abcf’ text2=‘acde’
当i = 3 j = 2 此时子数组为 子数组1 = ‘ab’  子数组2 = ‘a’ dp[2][1] = 1 text1[i] = ‘c’ text2[j] = 'c'  判断相等 dp[3][2] = dp[2][1] + 1 =2
此时 子数租变化 子数组1 = ‘abc’  子数组2 = ‘ac’ dp[3][2] = 2  i = 4  j = 3 text1[i[ = ‘f’ text2[j] = ‘e’ 不相等 dp[i][j] = max(dp[3][3],dp[4][2])  返回时 返回dp[-1][-1]


代码如下

    `class Solution:
        def longestCommonSubsequence(self, text1: str, text2: str) -> int:
            n = len(text1)
            m = len(text2)
            dp = [[0]*(m+1) for i in range(n+1)]
            for i in range(1,n+1):
                for j in range(1,m+1):
                    if text1[i-1] == text2[j-1]:
                        dp[i][j] = dp[i-1][j-1] + 1
                    else:
                        dp[i][j] = max(dp[i][j-1],dp[i-1][j])
            return dp[-1][-1]`

![6bb61116e6ff774cb97b3bd02677a36](https://user-images.githubusercontent.com/51037569/161278919-1bd633ff-1ee0-447e-92af-74ca0cfe6f12.png)


